#!/bin/false

#
# Project:        vfio-script
# Filename:       option_src
# Description:    Option and argument logic.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
# Version:        0.0.1
#

#
# TODO:
#
# - [ ] finish usage presentation.
#   - whitespace padding. Use columns?
# - [ ] test usage.
# - [x] write booleans to log when a function is successful or not.
#   - use these to track where exactly some task failed, and what completed.
#   - undo completed tasks, and notify of failed task.
#

#region traps

set -E    #NOTE: force `trap ERR` to be inherited.

trap \
  trap_any_exit \
  EXIT

trap \
  trap_any_error \
  ERR

#endregion

#region global parameters

declare SCRIPT_NAME="vfio-script"
declare SCRIPT_VERSION="0.0.1"
declare COLUMN_SIZE="$( tput cols )"

declare MULTIPLE_VFIO_SCRIPT="parse-iommu-devices"
declare RECOMMENDED_SCRIPT="auto-xorg"

declare DELIMITER=','

declare -ag LONG_OPTION_LIST=(
  "${!LONG_OPTION_WITHOUT_ARGUMENT_DICT[*]}"
  "${!LONG_OPTION_WITH_ARGUMENT_DICT[*]}"
)

declare -Ag ARGUMENT_AND_DESCRIPTION_DICT=()
declare -Ag ARGUMENT_AND_LONG_OPTION_DICT=()
declare -Ag LONG_AND_SHORT_OPTION_DICT=()
declare -Ag LONG_OPTION_AND_REGEX_DICT=()
declare -Ag LONG_OPTION_AND_DESCRIPTION_DICT=()
declare -Ag LONG_OPTION_AND_VALUE_TYPE_DICT=()
declare -Ag LONG_OPTION_WITH_ARGUMENT_DICT=()
declare -Ag LONG_OPTION_WITHOUT_ARGUMENT_DICT=()
declare -Ag VALUE_TYPE_AND_DESCRIPTION_DICT=()

  #region generic

  LONG_AND_SHORT_OPTION_DICT["help"]="h"
  LONG_OPTION_AND_DESCRIPTION_DICT["help"]="Print this help and exit."
  LONG_OPTION_WITHOUT_ARGUMENT_DICT["help"]=false

  LONG_AND_SHORT_OPTION_DICT["verbose"]="v"
  LONG_OPTION_AND_DESCRIPTION_DICT["verbose"]="Show more output."
  LONG_OPTION_WITHOUT_ARGUMENT_DICT["verbose"]=false

  #endregion

  #region supplemental

  ARGUMENT_AND_DESCRIPTION_DICT["prefer-stub-driver"]="Blacklist devices' with the older \"pci-stub\" driver instead of the \"vfio-pci\" driver.\nNote: not recommended as lower power states are not managed by the Host machine. Useful for stubborn devices."
  ARGUMENT_AND_LONG_OPTION_DICT["prefer-stub-driver"]="hardware-ids"

  LONG_AND_SHORT_OPTION_DICT["cmdline"]="c"
  LONG_OPTION_AND_REGEX_DICT["cmdline"]='[^"]*'
  LONG_OPTION_AND_VALUE_TYPE_DICT["cmdline"]="COMMANDS"
  LONG_OPTION_AND_DESCRIPTION_DICT["cmdline"]="Define the GRUB command line.\nNote: avoid escape characters, such as double-quote (\") and/or VFIO commands so as to prevent conflicts."
  LONG_OPTION_WITH_ARGUMENT_DICT["cmdline"]=""

  LONG_AND_SHORT_OPTION_DICT["drivers"]="d"
  LONG_OPTION_AND_REGEX_DICT["drivers"]="^[a-zA-Z]+(${DELIMITER}[a-zA-Z]+)*$"
  LONG_OPTION_AND_VALUE_TYPE_DICT["drivers"]="DRIVERS"
  LONG_OPTION_AND_DESCRIPTION_DICT["drivers"]="Specify which devices' drivers to override."
  LONG_OPTION_WITH_ARGUMENT_DICT["drivers"]=""

  LONG_OPTION_AND_REGEX_DICT["ignore-drivers"]="${LONG_OPTION_AND_REGEX_DICT["drivers"]}"
  LONG_OPTION_AND_DESCRIPTION_DICT["ignore-drivers"]="Specify which devices' drivers to not override."
  LONG_OPTION_WITH_ARGUMENT_DICT["ignore-drivers"]=""

  LONG_AND_SHORT_OPTION_DICT["hardware-ids"]="i"
  LONG_OPTION_AND_REGEX_DICT["hardware-ids"]="^(\s*${DELIMITER}\s*|\s*([A-Za-z0-9]{4}:\s*[A-Za-z0-9]{4})\s*${DELIMITER}\s*)*$"
  LONG_OPTION_AND_VALUE_TYPE_DICT["hardware-ids"]="IDS"
  LONG_OPTION_AND_DESCRIPTION_DICT["hardware-ids"]="Specify which devices' IDs to blacklist."
  LONG_OPTION_WITH_ARGUMENT_DICT["hardware-ids"]=""

  LONG_OPTION_AND_REGEX_DICT["ignore-hardware-ids"]="${LONG_OPTION_AND_REGEX_DICT["hardware-ids"]}"
  LONG_OPTION_AND_DESCRIPTION_DICT["ignore-hardware-ids"]="Specify which devices' IDs to whitelist."
  LONG_OPTION_WITH_ARGUMENT_DICT["ignore-hardware-ids"]=""

  LONG_AND_SHORT_OPTION_DICT["iommu-groups"]="g"
  LONG_OPTION_AND_REGEX_DICT["iommu-groups"]="^([0-9]+)(${DELIMITER}[0-9]+)*$"
  LONG_OPTION_AND_VALUE_TYPE_DICT["iommu-groups"]="GROUPS"
  LONG_OPTION_AND_DESCRIPTION_DICT["iommu-groups"]="Specify which IOMMU groups may be reserved for any Guest machine."
  LONG_OPTION_WITH_ARGUMENT_DICT["iommu-groups"]=""

  LONG_OPTION_AND_REGEX_DICT["ignore-iommu-groups"]="${LONG_OPTION_AND_REGEX_DICT["iommu-groups"]}"
  LONG_OPTION_AND_DESCRIPTION_DICT["ignore-iommu-groups"]="Specify which IOMMU groups may be reserved for the Host machine."
  LONG_OPTION_WITH_ARGUMENT_DICT["ignore-iommu-groups"]=""

  LONG_AND_SHORT_OPTION_DICT["override"]="o"
  LONG_OPTION_AND_DESCRIPTION_DICT["override"]="Override safety limits. Override a maximum amount of permutations, and/or features which may repeat a given command many times.\nNote: safety limits are five (5) permutations/repeats each.\nNote: no prompt at runtime."
  LONG_OPTION_WITHOUT_ARGUMENT_DICT["override"]=false

  #endregion

  #region VFIO

  ARGUMENT_AND_DESCRIPTION_DICT["conf"]="Write to various configuration files."
  ARGUMENT_AND_LONG_OPTION_DICT["conf"]="static-vfio"

  ARGUMENT_AND_DESCRIPTION_DICT["grub"]="Write to GRUB."
  ARGUMENT_AND_LONG_OPTION_DICT["grub"]="static-vfio"

  LONG_AND_SHORT_OPTION_DICT["dynamic-vfio"]="D"
  LONG_OPTION_AND_DESCRIPTION_DICT["dynamic-vfio"]="Define a temporary VFIO setup as a QEMU command line. Append to a Libvirt hook or a Guest machine configuration file. This VFIO setup may be created/destroyed on a Guest startup/shutdown."
  LONG_OPTION_WITHOUT_ARGUMENT_DICT["dynamic-vfio"]=false

  LONG_AND_SHORT_OPTION_DICT["multi-vfio"]="M"
  LONG_OPTION_AND_REGEX_DICT["multi-vfio"]='^(?!0)\d+$'
  LONG_OPTION_AND_VALUE_TYPE_DICT["multi-vfio"]="KERNELS"
  LONG_OPTION_AND_DESCRIPTION_DICT["multi-vfio"]="Define one or more persistent VFIO setup(s) as GRUB command line permutations\; setup(s) are defined as individual GRUB boot menu entries, where one permutation may be chosen at Host machine startup.\nNote: multiple GPUs on separate IOMMU groups will create multiple permutations.\nRequired executable(s): \"${MULTIPLE_VFIO_SCRIPT}\".\nOptional executable(s): \"${RECOMMENDED_SCRIPT}\"."
  LONG_OPTION_WITH_ARGUMENT_DICT["multi-vfio"]=""

  LONG_AND_SHORT_OPTION_DICT["static-vfio"]="S"
  LONG_OPTION_AND_REGEX_DICT["static-vfio"]='(?i)^(grub|conf)$'
  LONG_OPTION_AND_VALUE_TYPE_DICT["static-vfio"]="ARGUMENTS"
  LONG_OPTION_AND_DESCRIPTION_DICT["static-vfio"]="Define a persistent VFIO setup.\nOptional executable(s): \"${RECOMMENDED_SCRIPT}\"."
  LONG_OPTION_WITH_ARGUMENT_DICT["static-vfio"]=""

  LONG_OPTION_AND_DESCRIPTION_DICT["uninstall-vfio"]="Uninstall persistent VFIO setup(s)."
  LONG_OPTION_WITHOUT_ARGUMENT_DICT["uninstall-vfio"]=false

  #endregion

  #region value types

  VALUE_TYPE_AND_DESCRIPTION_DICT["ARGUMENTS"]="ARGUMENTS is the argument(s) for a given option."

  VALUE_TYPE_AND_DESCRIPTION_DICT["COMMANDS"]="COMMANDS is a whitespace-delimited list of command line arguments."

  VALUE_TYPE_AND_DESCRIPTION_DICT["DRIVERS"]="DRIVERS is a comma-delimited list of devices' driver names."

  VALUE_TYPE_AND_DESCRIPTION_DICT["GROUPS"]="GROUPS is a comma-delimited list of positive numbers.\nNote: to use all except pre-selected groups, do not use this option."

  VALUE_TYPE_AND_DESCRIPTION_DICT["IDS"]="IDS is a comma delimited list of devices' IDs."

  VALUE_TYPE_AND_DESCRIPTION_DICT["KERNELS"]="KERNELS is a comma-delimited list of positive non-zero numbers representing selected kernel(s); multiply the permutations by the number of available kernel(s) to be used (sorted newest to oldest).\nNote: to use all available, input '0'."

  #endregion

#endregion

#region logic

function trap_any_exit
{
  #TODO: develop.
  echo
}

function trap_any_error
{
  #TODO: develop.
  echo
}

function option_src_clean_up
{
  #TODO: develop.
  echo
}

#
# $@ : the options and arguments.
#
function option_src_main
{
  if ! option_src_parse_options "${@}"; then
    return 1
  fi

  return 0
}

#
# $@ : the options and arguments.
#
function option_src_parse_options
{
  #region getopt arguments setup

  long_options_delimited=""
  short_options_delimited=""

  for value in "${!LONG_OPTION_WITH_ARGUMENT_DICT[@]}"; do
    long_options_delimited+="${value}:,"
    short_options_delimited+="${value}:"
  done

  for value in "${!LONG_OPTION_WITHOUT_ARGUMENT_DICT[@]}"; do
    long_options_delimited+="${value},"
    short_options_delimited+="${value}"
  done

  if [[ "${long_options_delimited: -1}" == "," ]]; then
    long_options_delimited="${long_options_delimited%?}"
  fi

  if [[ "${short_options_delimited: -1}" == "," ]]; then
    short_options_delimited="${short_options_delimited%?}"
  fi

  #endregion

  var=$( \
    getopt \
      --longoptions "${long_options_delimited}" \
      --options "${short_options_delimited}" \
      --name "${SCRIPT_NAME}" \
      -- "${@}" \
  )

  if [[ ${?} -ne 0 ]]; then
    echo \
      -e \
      "Failed to parse options." \
      >&2

    exit 1
  fi

  eval \
    set \
    -- \
    "${var}"

  while true; do
    local long_option="$( option_src_parse_get_long_option "${1}" )"

    if [[ ${?} -ne 0 ]]; then
      echo \
        "Unexpected option: ${long_option}" \
        >&2

      exit 1
    fi

    local argument="${2}"

    if option_src_parse_option_with_argument \
        "${long_option}" \
        "${argument}" \
        &> /dev/null; then
      echo \
        "Expected argument: ${argument}" \
        >&1

      shift 2

    elif [[ "${long_option}" =~ "${!LONG_OPTION_WITHOUT_ARGUMENT_DICT[*]}" ]]; then
      LONG_OPTION_WITHOUT_ARGUMENT_DICT["${long_option}"]="true"
      shift 1

    elif [[ "${long_option}" == "" ]] \
      || [[ "${long_option}" == "--" ]]; then
      break

    else
      echo \
        "Unexpected option: ${long_option}" \
        >&2

      return 1
    fi

    echo \
      "Expected option: ${long_option}" \
      >&1
  done

  return 0
}

#
# $1      : the short option.
# returns : if short option is expected, return the long option.
#
function option_src_parse_get_long_option
{
  local long_option="${1}"

  if [[ "${long_option}" =~ "${!LONG_OPTION_WITH_ARGUMENT_DICT[*]}" ]]; then
    echo "${long_option}"
    return 0
  fi

  local short_option="${1}"

  if ! [[ "${short_option}" =~ "${LONG_AND_SHORT_OPTION_DICT[*]}" ]]; then
    return 1
  fi

  long_option="${LONG_AND_SHORT_OPTION_DICT["${1}"]}"
  echo "${long_option}"
  return 0
}

#
# $1      : the long option with an argument.
# $2      : the argument.
# returns : if long option has argument and argument matches regex, return argument.
#
function option_src_parse_option_with_argument
{
  local long_option="${1}"
  local argument="${2}"

  if ! [[ " ${!LONG_OPTION_WITH_ARGUMENT_DICT[*]} " == *" ${long_option} "* ]]; then
    return 0
  fi

  local regex="${LONG_OPTION_AND_REGEX_DICT["${long_option}"]}"

  if ! [[ "${argument}" =~ ${regex} ]]; then
    echo "Unexpected argument: ${argument}" >&2
    return 1
  fi

  LONG_OPTION_WITH_ARGUMENT_DICT["${long_option}"]="${argument}"
  echo "${argument}"
  return 0
}

#
# $1 : the whitespace prefix.
# $2 : the whitespace buffer.
# $3 : the long option with an argument.
#
function option_src_print_argument_and_description
{
  local whitespace_prefix="${1}"
  local whitespace_buffer="${2}"
  local long_option="${3}"

  if ! [[ " ${LONG_OPTION_LIST[*]} " == *" ${long_option} "* ]] \
    && ! [[ " ${ARGUMENT_AND_LONG_OPTION_DICT[*]} " == *" ${long_option} "* ]]; then
    echo
    return 0
  fi

  for argument in "${!ARGUMENT_AND_LONG_OPTION_DICT[@]}"; do
    local this_long_option="${ARGUMENT_AND_LONG_OPTION_DICT["${argument}"]}"

    if [[ "${long_option}" != "${this_long_option}" ]]; then
      continue
    fi

    local argument="${ARGUMENT_AND_LONG_OPTION_DICT["${long_option}"]}"
    local -a description="${ARGUMENT_AND_DESCRIPTION_DICT["${long_option}"]}"
    IFS=$'\n' read -rd '' -a lines <<< "$description"

    echo \
      -e \
      -n \
      "${whitespace_prefix}${short_option}--${long_option}${whitespace_buffer}"\
      "${lines[0]}\n"

    unset lines[0]

    for line in "${lines[@]}"; do
      echo \
        -e \
        -n \
        "\t\t\t${whitespace_prefix}${whitespace_buffer}${line}\n"
    done
  done

  return 0
}

#
# $1 : the whitespace prefix.
# $2 : the whitespace buffer.
# $@ : the long options.
#
function option_src_print_many_option_and_description
{
  local whitespace_prefix="${1}"
  local whitespace_buffer="${2}"

  for long_option in "${@}"; do
    option_src_print_this_option_and_description \
      "${whitespace_prefix}" \
      "${whitespace_buffer}" \
      "${long_option}"
  done
}

#
# $1 : the whitespace prefix.
# $2 : the whitespace buffer.
# $3 : the long option with an argument.
#
function option_src_print_this_option_and_description
{
  local whitespace_prefix="${1}"
  local whitespace_buffer="${2}"
  local long_option="${3}"

  if ! [[ " ${LONG_OPTION_LIST[*]} " == *" ${long_option} "* ]]; then
    echo
    return 0
  fi

  local short_option="${LONG_AND_SHORT_OPTION_DICT["${long_option}"]}"

  if [[ "${short_option}" != "" ]]; then
    short_option="-${short_option},"
  fi

  local argument="${ARGUMENT_AND_LONG_OPTION_DICT["${long_option}"]}"
  local full_description="${LONG_OPTION_AND_DESCRIPTION_DICT["${long_option}"]}"
  local value_type="${LONG_OPTION_AND_VALUE_TYPE_DICT["${long_option}"]}"

  if [[ "${value_type}" != "" ]]; then
    local value_description="${VALUE_TYPE_AND_DESCRIPTION_DICT["${value_type}"]}"

    if [[ ${?} -eq 0 ]]; then
      full_description+="\n${value_description}"
    fi
  fi

  IFS=$'\n' read -rd '' -a lines <<< "$( echo -e "${full_description}" )"

  echo \
    -e \
    -n \
    "${whitespace_prefix}${short_option}--${long_option}${whitespace_buffer}"\
    "${lines[0]}\n"

  unset lines[0]

  for line in "${lines[@]}"; do
    echo \
      -e \
      -n \
      "\t\t\t${whitespace_prefix}${whitespace_buffer}${line}\n"
  done

  option_src_print_argument_and_description \
    "${argument}" \
    "${whitespace_prefix}" \
    "${whitespace_buffer}"

  return 0
}

function option_src_print_usage
{
  echo \
    -e \
    -n \
    "Usage:\t${SCRIPT_NAME} ARGS"\
    "\nEasily automate the install or uninstall of a hardware-passthrough"\
    "(VFIO) setup on a Linux machine. Select from either a dynamic, GRUB, or"\
    "static setup."\
    "\nVersion ${SCRIPT_VERSION}"

  option_src_print_many_option_and_description \
    "\t" \
    "\t" \
    "help" \
    "override" \
    "verbose"

  echo \
    -e \
    "VFIO setup options:\n"

  option_src_print_this_option_and_description \
    "\t" \
    "\t" \
    "dynamic-vfio"

  option_src_print_this_option_and_description \
    "\t" \
    "\t\t" \
    "multi-vfio"

  option_src_print_many_option_and_description \
    "\t" \
    "\t" \
    "static-vfio" \
    "uninstall-vfio"

  echo \
    -e \
    -n \
    "Supplemental options:"

  option_src_print_many_option_and_description \
    "\t" \
    "\t\t" \
    "cmdline" \
    "drivers"

  option_src_print_many_option_and_description \
    "\t" \
    "\t" \
    "hardware-ids" \
    "iommu-groups" \
    "ignore-drivers" \
    "ignore-hardware-ids" \
    "ignore-iommu-groups"
}

#endregion