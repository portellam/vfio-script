#!/bin/false

#
# Project:        vfio-script
# Filename:       option_src
# Description:    Argument logic.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
# Version:        0.0.1
#

#
# TODO:
# - [ ] write booleans to log when a function is successful or not.
#   - use these to track where exactly some task failed, and what completed.
#   - undo completed tasks, and notify of failed task.
#

#region traps

set -E    #NOTE: force `trap ERR` to be inherited.

trap \
  trap_any_exit \
  EXIT

trap \
  trap_any_error \
  ERR

#endregion

#region global parameters

declare SCRIPT_NAME="vfio-script"
declare SCRIPT_VERSION="0.0.1"
declare COLUMN_SIZE="$( tput cols )"

declare DELIMITER=','

  #region options

  declare -ag LONG_OPTION_WITHOUT_ARGUMENT_DICT=(
    #region generic

    ["help"]=false,
    ["verbose"]=false,

    #endregion

    #region supplmental

    ["override"]=false,

    #endregion

    #region VFIO

    ["dynamic-vfio"]=false,
    ["uninstall-vfio"]=false,

    #endregion
  )

  declare -Ag LONG_OPTION_WITH_ARGUMENT_DICT=(
    #region supplemental

    ["cmdline"]="",
    ["drivers"]="",
    ["hardware-ids"]="",
    ["iommu-groups"]="",

    #endregion

    #region VFIO

    ["multi-vfio"]="",
    ["static-vfio"]="",

    #endregion
  )

  declare -Ag LONG_AND_SHORT_OPTION_DICT=()
  declare -Ag LONG_OPTION_AND_REGEX_DICT=()

    #region generic

    LONG_AND_SHORT_OPTION_DICT["help"]="h"

    #endregion

    #region supplmental

    LONG_AND_SHORT_OPTION_DICT["cmdline"]="c"
    LONG_OPTION_AND_REGEX_DICT["cmdline"]='[^"]*'

    LONG_AND_SHORT_OPTION_DICT["drivers"]="d"
    LONG_OPTION_AND_REGEX_DICT["drivers"]="^[a-zA-Z]+(${DELIMITER}[a-zA-Z]+)*$"

    LONG_AND_SHORT_OPTION_DICT["hardware-ids"]="i"
    LONG_OPTION_AND_REGEX_DICT["hardware-ids"]="^(\s*${DELIMITER}\s*|\s*([A-Za-z0-9]{4}:\s*[A-Za-z0-9]{4})\s*${DELIMITER}\s*)*$"

    LONG_AND_SHORT_OPTION_DICT["iommu-groups"]="g"
    LONG_OPTION_AND_REGEX_DICT["iommu-groups"]="^([0-9]+)(${DELIMITER}[0-9]+)*$"

    LONG_AND_SHORT_OPTION_DICT["override"]="o"

    #endregion

    #region VFIO

    LONG_AND_SHORT_OPTION_DICT["dynamic-vfio"]="D"

    LONG_AND_SHORT_OPTION_DICT["multi-vfio"]="M"
    LONG_OPTION_AND_REGEX_DICT["multi-vfio"]='^(?!0)\d+$'

    LONG_AND_SHORT_OPTION_DICT["static-vfio"]="S"
    LONG_OPTION_AND_REGEX_DICT["static-vfio"]='(?i)^(grub|conf)$'

    #endregion

  #endregion

  #region usage

  declare -Ag_ARGUMENT_AND_LONG_OPTION_DICT=(
    ["conf"]="static-vfio",
    ["grub"]="static-vfio",
    ["prefer-stub-driver"]="hardware-ids",
  )

  declare -Ag LONG_OPTION_AND_VALUE_TYPE_DICT=(
    #region supplemental

    ["cmdline"]="COMMANDS",
    ["drivers"]="DRIVERS",
    ["hardware-ids"]="IDS",
    ["iommu-groups"]="GROUPS",

    #endregion

    #region VFIO

    ["multi-vfio"]="KERNELS",
    ["static-vfio"]="ARGUMENTS",

    #endregion
  )

  declare -ag LONG_OPTION_AND_DESCRIPTION_DICT=(
    #region generic

    ["help"]="Print this help and exit.",
    ["verbose"]="Show more output.",

    #endregion

    #region supplmental

    ["cmdline"]="Define the GRUB command line."\
      "\nNote: avoid escape characters, such as double-quote (\") and/or VFIO"\
      " commands so as to prevent conflicts.",

    ["drivers"]="Specify which devices' drivers to override.",

    ["hardware-ids"]="Specify which devices' IDs to blacklist.",

    ["iommu-groups"]="Specify which IOMMU groups may be reserved for any Guest"\
      " machine.",

    ["override"]="Override safety limits. Override a maximum amount of"\
      " permutations, and/or features which may repeat a given command many"\
      " times."\
      "\nNote: safety limits are five (5) permutations/repeats each."\
      "\nNote: no prompt at runtime.",

    ["prefer-stub-driver"]="Blacklist devices' with the older \"pci-stub\""\
      "driver instead of the \"vfio-pci\" driver."\
      "\nNote: not recommended as lower power states are not managed by the"\
      " Host machine. Useful for stubborn devices.",

    #endregion

    #region VFIO

    ["dynamic-vfio"]="Define a temporary VFIO setup as a QEMU command line."\
      " Append to a Libvirt hook or a Guest machine configuration file. This"\
      " VFIO setup may be created/destroyed on a Guest startup/shutdown.",

    ["multi-vfio"]="Define one or more persistent VFIO setup(s) as GRUB"\
      " command line permutations; setup(s) are defined as individual GRUB"\
      " boot menu entries, where one permutation may be chosen at Host machine"\
      " startup."\
      "\nNote: multiple GPUs on separate IOMMU groups will create multiple"\
      "permutations.",

    ["static-vfio"]="Define a persistent VFIO setup.",

    ["uninstall-vfio"]="Uninstall persistent VFIO setup(s).",

    #endregion
  )

  declare -Ag VALUE_TYPE_AND_DESCRIPTION_DICT=(
    ["ARGUMENTS"]="ARGUMENTS is the argument(s) of a given option.",

    ["COMMANDS"]="COMMANDS is a whitespace-delimited list of command line"\
      " arguments.",

    ["DRIVERS"]="DRIVERS is a comma-delimited list of devices' driver names.",

    ["GROUPS"]="GROUPS is a comma-delimited list of positive numbers."\
      "\nNote: to use all except pre-selected groups, do not use this option.",

    ["IDS"]="IDS is a comma delimited list of devices' IDs.",

    ["KERNELS"]="KERNELS is a comma-delimited list of positive non-zero"\
      " numbers representing selected kernel(s); multiply the permutations by"\
      " the number of available kernel(s) to be used"\
      " (sorted newest to oldest)."\
      "\nNote: to use all available, input '0'.",
  )

  #endregion

#endregion

#region logic

function trap_any_exit
{
  #TODO: develop.
  echo
}

function trap_any_error
{
  #TODO: develop.
  echo
}

function src_clean_up
{
  #TODO: develop.
  echo
}

#
# $@ : the options and arguments.
#
function src_parse_options
{
  #region getopt arguments setup

  long_options_delimited=""
  short_options_delimited=""

  for value in "${!LONG_OPTION_WITH_ARGUMENT_DICT[@]}"; do
    long_options_delimited+="${value}:,"
    short_options_delimited+="${value}:"
  done

  for value in "${!LONG_OPTION_WITHOUT_ARGUMENT_DICT[@]}"; do
    long_options_delimited+="${value},"
    short_options_delimited+="${value}"
  done

  if [[ "${long_options_delimited: -1}" = "," ]]; then
    long_options_delimited="${long_options_delimited%?}"
  fi

  if [[ "${short_options_delimited: -1}" = "," ]]; then
    short_options_delimited="${short_options_delimited%?}"
  fi

  #endregion

  var=$( \
    getopt \
      --longoptions "${long_options_delimited}" \
      --options "${short_options_delimited}" \
      --name "${SCRIPT_NAME}" \
      -- "${@}" \
  )

  if [[ ${?} -ne 0 ]]; then
    echo \
      -e \
      "Failed to parse options." \
      >&2

    exit 1
  fi

  eval \
    set \
    -- \
    "${var}"

  while true; do
    local long_option="$( src_parse_get_long_option "${1}" )"

    if [[ ${?} -ne 0 ]]; then
      echo \
        "Unexpected option: ${long_option}" \
        >&2

      exit 1
    fi

    local argument="${2}"

    if src_parse_option_with_argument \
        "${long_option}" \
        "${argument}" \
        &> /dev/null; then
      shift 2

    elif [[ "${long_option}" =~ "${!LONG_OPTION_WITHOUT_ARGUMENT_DICT[*]}" ]]; then
      LONG_OPTION_WITHOUT_ARGUMENT_DICT["${long_option}"]="true"
      shift 1

    elif [[ "${long_option}" == "" ]] \
      || [[ "${long_option}" == "--" ]]; then
      break

    else
      echo \
        "Unexpected option: ${long_option}" \
        >&2

      return 1
    fi
  done

  return 0
}

#
# $1      : the short option.
# returns : if short option is expected, return the long option.
#
function src_parse_get_long_option
{
  local long_option="${1}"

  if [[ "${long_option}" =~ "${!LONG_OPTION_WITH_ARGUMENT_DICT[*]}" ]]; then
    echo "${long_option}"
    return 0
  fi

  local short_option="${1}"

  if ! [[ "${short_option}" =~ "${LONG_AND_SHORT_OPTION_DICT[*]}" ]]; then
    return 1
  fi

  long_option="${LONG_AND_SHORT_OPTION_DICT["${1}"]}"
  echo "${long_option}"
  return 0
}

#
# $1      : the long option with an argument.
# $2      : the argument.
# returns : if long option has argument and argument matches regex, return argument.
#
function src_parse_option_with_argument
{
  local long_option="${1}"
  local argument="${2}"

  if ! [[ "${long_option}" =~ "${!LONG_OPTION_WITH_ARGUMENT_DICT[*]}" ]]; then
    return 0
  fi

  local regex="${LONG_OPTION_AND_REGEX_DICT["${long_option}"]}"

  if ! [[ "${argument}" =~ ${regex} ]]; then
    echo "Unexpected argument: ${argument}" >&2
    return 1
  fi

  LONG_OPTION_WITH_ARGUMENT_DICT["${long_option}"]="${argument}"
  echo "${argument}"
  return 0
}

#endregion