#!/bin/false

#
# Project:        vfio-script
# Filename:       option_src
# Description:    Option and argument logic.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
# Version:        0.0.1
#

#
# TODO:
#
# - [ ] finish usage presentation.
#   - whitespace padding. Use columns?
# - [ ] test usage.
# - [x] write booleans to log when a function is successful or not.
#   - use these to track where exactly some task failed, and what completed.
#   - undo completed tasks, and notify of failed task.
#

#region traps

set -E    #NOTE: force `trap ERR` to be inherited.

trap \
  trap_any_exit \
  EXIT

trap \
  trap_any_error \
  ERR

#endregion

#region global parameters

declare SCRIPT_NAME="vfio-script"
declare SCRIPT_VERSION="0.0.1"
declare COLUMN_SIZE="$( tput cols )"

declare MULTIPLE_VFIO_SCRIPT="parse-iommu-devices"
declare RECOMMENDED_SCRIPT="auto-xorg"

declare DELIMITER=','

  #region options

  declare -ag LONG_OPTION_WITHOUT_ARGUMENT_DICT=(
    #region generic

    ["help"]=false,
    ["verbose"]=false,

    #endregion

    #region supplmental

    ["override"]=false,

    #endregion

    #region VFIO

    ["dynamic-vfio"]=false,
    ["uninstall-vfio"]=false,

    #endregion
  )

  declare -Ag LONG_OPTION_WITH_ARGUMENT_DICT=(
    #region supplemental

    ["cmdline"]="",
    ["drivers"]="",
    ["hardware-ids"]="",
    ["iommu-groups"]="",

    ["ignore-drivers"]="",
    ["ignore-hardware-ids"]="",
    ["ignore-iommu-groups"]="",

    #endregion

    #region VFIO

    ["multi-vfio"]="",
    ["static-vfio"]="",

    #endregion
  )

  declare -Ag LONG_AND_SHORT_OPTION_DICT=()
  declare -Ag LONG_OPTION_AND_REGEX_DICT=()

    #region generic

    LONG_AND_SHORT_OPTION_DICT["help"]="h"

    #endregion

    #region supplmental

    LONG_AND_SHORT_OPTION_DICT["cmdline"]="c"
    LONG_OPTION_AND_REGEX_DICT["cmdline"]='[^"]*'

    LONG_AND_SHORT_OPTION_DICT["drivers"]="d"
    LONG_OPTION_AND_REGEX_DICT["drivers"]="^[a-zA-Z]+(${DELIMITER}[a-zA-Z]+)*$"
    LONG_OPTION_AND_REGEX_DICT["ignore-drivers"]="${LONG_OPTION_AND_REGEX_DICT["drivers"]}"

    LONG_AND_SHORT_OPTION_DICT["hardware-ids"]="i"
    LONG_OPTION_AND_REGEX_DICT["hardware-ids"]="^(\s*${DELIMITER}\s*|\s*([A-Za-z0-9]{4}:\s*[A-Za-z0-9]{4})\s*${DELIMITER}\s*)*$"
    LONG_OPTION_AND_REGEX_DICT["ignore-hardware-ids"]="${LONG_OPTION_AND_REGEX_DICT["hardware-ids"]}"

    LONG_AND_SHORT_OPTION_DICT["iommu-groups"]="g"
    LONG_OPTION_AND_REGEX_DICT["iommu-groups"]="^([0-9]+)(${DELIMITER}[0-9]+)*$"
    LONG_OPTION_AND_REGEX_DICT["ignore-iommu-groups"]="${LONG_OPTION_AND_REGEX_DICT["iommu-groups"]}"

    LONG_AND_SHORT_OPTION_DICT["override"]="o"

    #endregion

    #region VFIO

    LONG_AND_SHORT_OPTION_DICT["dynamic-vfio"]="D"

    LONG_AND_SHORT_OPTION_DICT["multi-vfio"]="M"
    LONG_OPTION_AND_REGEX_DICT["multi-vfio"]='^(?!0)\d+$'

    LONG_AND_SHORT_OPTION_DICT["static-vfio"]="S"
    LONG_OPTION_AND_REGEX_DICT["static-vfio"]='(?i)^(grub|conf)$'

    #endregion

  #endregion

  #region usage

  declare -Ag ARGUMENT_AND_DESCRIPTION_DICT=(
    ["conf"]="Write to various configuration files.",
    ["grub"]="Write to GRUB.",

    ["prefer-stub-driver"]="Blacklist devices' with the older \"pci-stub\""\
      "driver instead of the \"vfio-pci\" driver."\
      "\nNote: not recommended as lower power states are not managed by the"\
      " Host machine. Useful for stubborn devices.",
  )

  declare -Ag ARGUMENT_AND_LONG_OPTION_DICT=(
    ["conf"]="static-vfio",
    ["grub"]="static-vfio",
    ["prefer-stub-driver"]="hardware-ids",
  )

  declare -ag LONG_OPTION_AND_DESCRIPTION_DICT=(
    #region generic

    ["help"]="Print this help and exit.",
    ["verbose"]="Show more output.",

    #endregion

    #region supplmental

    ["cmdline"]="Define the GRUB command line."\
      "\nNote: avoid escape characters, such as double-quote (\") and/or VFIO"\
      " commands so as to prevent conflicts.",

    ["drivers"]="Specify which devices' drivers to override.",

    ["ignore-drivers"]="Specify which devices' drivers to not override.",

    ["hardware-ids"]="Specify which devices' IDs to blacklist.",

    ["ignore-hardware-ids"]="Specify which devices' IDs to whitelist.",

    ["iommu-groups"]="Specify which IOMMU groups may be reserved for any Guest"\
      " machine.",

    ["ignore-iommu-groups"]="Specify which IOMMU groups may be reserved for"\
      " the Host machine.",

    ["override"]="Override safety limits. Override a maximum amount of"\
      " permutations, and/or features which may repeat a given command many"\
      " times."\
      "\nNote: safety limits are five (5) permutations/repeats each."\
      "\nNote: no prompt at runtime.",

    #endregion

    #region VFIO

    ["dynamic-vfio"]="Define a temporary VFIO setup as a QEMU command line."\
      " Append to a Libvirt hook or a Guest machine configuration file. This"\
      " VFIO setup may be created/destroyed on a Guest startup/shutdown.",

    ["multi-vfio"]="Define one or more persistent VFIO setup(s) as GRUB"\
      " command line permutations; setup(s) are defined as individual GRUB"\
      " boot menu entries, where one permutation may be chosen at Host machine"\
      " startup."\
      "\nNote: multiple GPUs on separate IOMMU groups will create multiple"\
      "permutations.",
      "\nRequired executable(s): \"${MULTIPLE_VFIO_SCRIPT}\".",
      "\nOptional executable(s): \"${RECOMMENDED_SCRIPT}\".",

    ["static-vfio"]="Define a persistent VFIO setup.",
      "\nOptional executable(s): \"${RECOMMENDED_SCRIPT}\".",

    ["uninstall-vfio"]="Uninstall persistent VFIO setup(s).",

    #endregion
  )

  declare -Ag LONG_OPTION_AND_VALUE_TYPE_DICT=(
    #region supplemental

    ["cmdline"]="COMMANDS",
    ["drivers"]="DRIVERS",
    ["hardware-ids"]="IDS",
    ["iommu-groups"]="GROUPS",

    #endregion

    #region VFIO

    ["multi-vfio"]="KERNELS",
    ["static-vfio"]="ARGUMENTS",

    #endregion
  )

  declare -Ag VALUE_TYPE_AND_DESCRIPTION_DICT=(
    ["ARGUMENTS"]="ARGUMENTS is the argument(s) for a given option.",

    ["COMMANDS"]="COMMANDS is a whitespace-delimited list of command line"\
      " arguments.",

    ["DRIVERS"]="DRIVERS is a comma-delimited list of devices' driver names.",

    ["GROUPS"]="GROUPS is a comma-delimited list of positive numbers."\
      "\nNote: to use all except pre-selected groups, do not use this option.",

    ["IDS"]="IDS is a comma delimited list of devices' IDs.",

    ["KERNELS"]="KERNELS is a comma-delimited list of positive non-zero"\
      " numbers representing selected kernel(s); multiply the permutations by"\
      " the number of available kernel(s) to be used"\
      " (sorted newest to oldest)."\
      "\nNote: to use all available, input '0'.",
  )

  #endregion

#endregion

#region logic

function trap_any_exit
{
  #TODO: develop.
  echo
}

function trap_any_error
{
  #TODO: develop.
  echo
}

function option_src_clean_up
{
  #TODO: develop.
  echo
}

#
# $@ : the options and arguments.
#
function option_src_main
{
  if ! option_src_parse_options "${@}"; then
    return 1
  fi

  return 0
}

#
# $@ : the options and arguments.
#
function option_src_parse_options
{
  #region getopt arguments setup

  long_options_delimited=""
  short_options_delimited=""

  for value in "${!LONG_OPTION_WITH_ARGUMENT_DICT[@]}"; do
    long_options_delimited+="${value}:,"
    short_options_delimited+="${value}:"
  done

  for value in "${!LONG_OPTION_WITHOUT_ARGUMENT_DICT[@]}"; do
    long_options_delimited+="${value},"
    short_options_delimited+="${value}"
  done

  if [[ "${long_options_delimited: -1}" = "," ]]; then
    long_options_delimited="${long_options_delimited%?}"
  fi

  if [[ "${short_options_delimited: -1}" = "," ]]; then
    short_options_delimited="${short_options_delimited%?}"
  fi

  #endregion

  var=$( \
    getopt \
      --longoptions "${long_options_delimited}" \
      --options "${short_options_delimited}" \
      --name "${SCRIPT_NAME}" \
      -- "${@}" \
  )

  if [[ ${?} -ne 0 ]]; then
    echo \
      -e \
      "Failed to parse options." \
      >&2

    exit 1
  fi

  eval \
    set \
    -- \
    "${var}"

  while true; do
    local long_option="$( option_src_parse_get_long_option "${1}" )"

    if [[ ${?} -ne 0 ]]; then
      echo \
        "Unexpected option: ${long_option}" \
        >&2

      exit 1
    fi

    local argument="${2}"

    if option_src_parse_option_with_argument \
        "${long_option}" \
        "${argument}" \
        &> /dev/null; then
      echo \
        "Expected argument: ${argument}" \
        >&1

      shift 2

    elif [[ "${long_option}" =~ "${!LONG_OPTION_WITHOUT_ARGUMENT_DICT[*]}" ]]; then
      LONG_OPTION_WITHOUT_ARGUMENT_DICT["${long_option}"]="true"
      shift 1

    elif [[ "${long_option}" == "" ]] \
      || [[ "${long_option}" == "--" ]]; then
      break

    else
      echo \
        "Unexpected option: ${long_option}" \
        >&2

      return 1
    fi

    echo \
      "Expected option: ${long_option}" \
      >&1
  done

  return 0
}

#
# $1      : the short option.
# returns : if short option is expected, return the long option.
#
function option_src_parse_get_long_option
{
  local long_option="${1}"

  if [[ "${long_option}" =~ "${!LONG_OPTION_WITH_ARGUMENT_DICT[*]}" ]]; then
    echo "${long_option}"
    return 0
  fi

  local short_option="${1}"

  if ! [[ "${short_option}" =~ "${LONG_AND_SHORT_OPTION_DICT[*]}" ]]; then
    return 1
  fi

  long_option="${LONG_AND_SHORT_OPTION_DICT["${1}"]}"
  echo "${long_option}"
  return 0
}

#
# $1      : the long option with an argument.
# $2      : the argument.
# returns : if long option has argument and argument matches regex, return argument.
#
function option_src_parse_option_with_argument
{
  local long_option="${1}"
  local argument="${2}"

  if ! [[ "${long_option}" =~ "${!LONG_OPTION_WITH_ARGUMENT_DICT[*]}" ]]; then
    return 0
  fi

  local regex="${LONG_OPTION_AND_REGEX_DICT["${long_option}"]}"

  if ! [[ "${argument}" =~ ${regex} ]]; then
    echo "Unexpected argument: ${argument}" >&2
    return 1
  fi

  LONG_OPTION_WITH_ARGUMENT_DICT["${long_option}"]="${argument}"
  echo "${argument}"
  return 0
}


#
# $1 : the long option with an argument.
# $2 : the whitespace prefix.
# $3 : the whitespace buffer.
#
function option_src_print_argument_and_description
{
  local long_option="${1}"

  if ! [[ "${long_option}" =~ "${!LONG_OPTION_WITH_ARGUMENT_DICT[*]}" ]] \
    || ! ! [[ "${long_option}" =~ "${ARGUMENT_AND_LONG_OPTION_DICT[*]}" ]]; then
    echo
    return 0
  fi

  local argument="${ARGUMENT_AND_LONG_OPTION_DICT["${long_option}"]}"
  local description="${ARGUMENT_AND_DESCRIPTION_DICT["${long_option}"]}"

  echo \
    -e \
    "${2}${argument}${3}${description}"

  return 0
}

#
# $1 : the long option with an argument.
# $2 : the whitespace prefix.
# $3 : the whitespace buffer.
#
function option_src_print_option_and_description
{
  local long_option="${1}"

  if ! [[ "${long_option}" =~ "${!LONG_OPTION_WITH_ARGUMENT_DICT[*]}" ]] \
    || ! ! [[ "${long_option}" =~ "${ARGUMENT_AND_LONG_OPTION_DICT[*]}" ]]; then
    echo
    return 0
  fi

  local argument="${ARGUMENT_AND_LONG_OPTION_DICT["${long_option}"]}"
  local full_description="${ARGUMENT_AND_DESCRIPTION_DICT["${long_option}"]}"
  local value_type="${LONG_OPTION_AND_VALUE_TYPE_DICT["${long_option}"]}"

  if [[ ${?} -eq 0 ]]; then
    local value_description="${VALUE_TYPE_AND_DESCRIPTION_DICT["${value_type}"]}"

    if [[ ${?} -eq 0 ]]; then
      full_description+="\n${value_description}"
    fi
  fi

  echo \
    -e \
    "${2}${argument}${3}${description}"

  return 0
}

#
# DESC  : Does some cool shit maybe you didn't know.
#
function option_src_print_usage
{
  echo \
    -e \
    "Usage:\t${SCRIPT_NAME} ARGS"\
    "\nVersion ${SCRIPT_VERSION}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["help"]}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["override"]}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["verbose"]}"\
    "\n"\
    "\nVFIO setup options:"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["dynamic-vfio"]}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["multi-vfio"]}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["static-vfio"]}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["uninstall-vfio"]}"\
    "\n"\
    "\nSupplemental options:"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["cmdline"]}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["drivers"]}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["hardware-ids"]}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["iommu-groups"]}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["ignore-drivers"]}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["ignore-hardware-ids"]}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["ignore-iommu-groups"]}"\
    "\n"\
    "\n${LONG_OPTION_AND_DESCRIPTION_DICT["prefer-stub-driver"]}"
}

#endregion